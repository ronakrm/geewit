#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/gwt"
CONFIG_FILE="${GWT_CONFIG_FILE:-$CONFIG_DIR/config}"

DEFAULT_BASE_BRANCH="main"
DEFAULT_COLORS=(red green yellow blue magenta cyan colour208 colour196 colour202 colour226 colour46 colour51 colour201 colour93 colour99 colour33 colour166 colour184 colour214 colour220)

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$CONFIG_FILE"
    fi
}

ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
}

set_config_value() {
    local key="$1"
    local value="$2"
    ensure_config_dir
    touch "$CONFIG_FILE"
    local escaped
    escaped=$(printf '%q' "$value")
    local escaped_sed
    escaped_sed="${escaped//\\/\\\\}"
    escaped_sed="${escaped_sed//&/\\&}"
    if grep -q "^${key}=" "$CONFIG_FILE"; then
        sed -i "s|^${key}=.*$|${key}=${escaped_sed}|" "$CONFIG_FILE"
    else
        printf '%s=%s\n' "$key" "$escaped" >> "$CONFIG_FILE"
    fi
}

print_usage() {
    cat <<'EOS'
Usage: gwt <command> [args]

Core commands
  new <branch> [base]     Create a worktree + tmux session (base defaults to main)
                          Use --agent CMD or --no-agent to override the agent pane
  switch <branch>         Attach to an existing session
  list                    List worktrees and matching tmux sessions
  remove <branch>         Remove worktree and tmux session
  cleanup [base]          Remove worktrees already merged into base (default: main)
  status                  Show git status for every worktree
  push [remote]           Push current branch (default remote: origin)
  from-pr <number>        Create a worktree from a GitHub PR (requires gh)

Tmux integration
  tmux-status [path]      Internal helper for the tmux status line

Agent configuration
  agent show              Show current agent command
  agent set <command>     Update the command used to start the agent pane
  agent clear             Remove the agent command

Other
  config-path             Print the config file location
  completion <shell>      Print shell completion script (bash|zsh)
  help                    Show this message
EOS
}

require_git_repo() {
    if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
        echo "gwt: must be run inside a git repository" >&2
        exit 1
    fi
}

require_command() {
    local cmd="$1"
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "gwt: missing required command '$cmd'" >&2
        exit 1
    fi
}

repo_root() {
    git rev-parse --show-toplevel
}

repo_name() {
    basename "$(repo_root)"
}

resolve_worktree_base() {
    local root="$1"
    local base="${GWT_WORKTREE_BASE:-}"
    if [[ -z "$base" ]]; then
        base="$(cd "$root/.." && pwd)"
    elif [[ "${base:0:1}" != "/" ]]; then
        mkdir -p "$root/$base"
        base="$(cd "$root/$base" && pwd)"
    else
        mkdir -p "$base"
    fi
    echo "$base"
}

worktree_path_for_branch() {
    local branch="$1"
    local root
    root="$(repo_root)"
    local base
    base="$(resolve_worktree_base "$root")"
    local prefix="${GWT_PREFIX:-}"
    local path="$base/${prefix}$(repo_name)-$branch"
    echo "$path"
}

existing_worktree_path_for_branch() {
    local branch="$1"
    local current_path=""
    while IFS= read -r line; do
        if [[ "$line" == worktree\ * ]]; then
            current_path="${line#worktree }"
        elif [[ "$line" == branch\ * ]]; then
            local ref="${line#branch }"
            if [[ "$ref" == "refs/heads/$branch" ]]; then
                echo "$current_path"
                return 0
            fi
        fi
    done < <(git worktree list --porcelain 2>/dev/null)
    return 1
}

resolve_worktree_dir_for_branch() {
    local branch="$1"
    local path
    path="$(existing_worktree_path_for_branch "$branch" || true)"
    if [[ -n "$path" ]]; then
        echo "$path"
    else
        worktree_path_for_branch "$branch"
    fi
}

session_name_for_branch() {
    printf '%s-%s' "$(repo_name)" "$1"
}

copy_env_if_present() {
    local root
    root="$(repo_root)"
    local worktree_dir="$1"
    if [[ -f "$root/.env" ]]; then
        cp "$root/.env" "$worktree_dir/.env"
    fi
}

find_workspace_file() {
    local root
    root="$(repo_root)"
    find "$root" -maxdepth 1 -type f -name '*.code-workspace' -print -quit
}

update_workspace_for_branch() {
    local action="$1"
    local branch="$2"
    local workspace_file
    workspace_file="$(find_workspace_file)"
    if [[ -z "$workspace_file" ]]; then
        return
    fi
    if ! command -v python3 >/dev/null 2>&1; then
        echo "gwt: python3 required to update workspace file" >&2
        return
    fi
    local worktree_dir
    worktree_dir="$(worktree_path_for_branch "$branch")"
    python3 - "$workspace_file" "$worktree_dir" "$action" <<'PY'
import json
import os
import sys

workspace_file, worktree_dir, action = sys.argv[1:4]

try:
    with open(workspace_file, 'r', encoding='utf-8') as handle:
        data = json.load(handle)
except (OSError, json.JSONDecodeError):
    sys.exit(0)

if not isinstance(data, dict):
    sys.exit(0)

folders = data.get('folders')
if not isinstance(folders, list):
    folders = []
    data['folders'] = folders

workspace_root = os.path.dirname(workspace_file) or os.curdir
rel_path = os.path.relpath(worktree_dir, workspace_root)
rel_path = rel_path.replace(os.path.sep, '/')
abs_path = os.path.abspath(worktree_dir).replace(os.path.sep, '/')

def normalise(value):
    return (value or '').replace('\\', '/')

targets = {normalise(rel_path), normalise(abs_path)}

changed = False

if action == 'add':
    for folder in folders:
        if isinstance(folder, dict) and normalise(folder.get('path')) in targets:
            break
    else:
        folders.append({'path': rel_path})
        changed = True
elif action == 'remove':
    new_folders = []
    for folder in folders:
        if isinstance(folder, dict) and normalise(folder.get('path')) in targets:
            changed = True
            continue
        new_folders.append(folder)
    if changed:
        data['folders'] = new_folders

if changed:
    with open(workspace_file, 'w', encoding='utf-8') as handle:
        json.dump(data, handle, indent=4)
        handle.write('\n')
PY
}

choose_random_color() {
    local idx=$((RANDOM % ${#DEFAULT_COLORS[@]}))
    echo "${DEFAULT_COLORS[$idx]}"
}

branch_exists_locally() {
    git show-ref --quiet --verify "refs/heads/$1"
}

branch_exists_remote() {
    git ls-remote --exit-code --heads origin "$1" >/dev/null 2>&1
}

create_worktree() {
    local branch="$1"
    local base_branch="$2"
    local worktree_dir
    worktree_dir="$(worktree_path_for_branch "$branch")"

    echo "→ creating worktree at $worktree_dir"
    if branch_exists_locally "$branch" || branch_exists_remote "$branch"; then
        git worktree add "$worktree_dir" "$branch"
    else
        git worktree add -b "$branch" "$worktree_dir" "$base_branch"
    fi
    copy_env_if_present "$worktree_dir"
}

configure_tmux_session() {
    local branch="$1"
    local agent_override="${2:-}"
    local agent_override_set="${3:-0}"
    local worktree_dir
    worktree_dir="$(resolve_worktree_dir_for_branch "$branch")"
    local session
    session="$(session_name_for_branch "$branch")"

    tmux kill-session -t "$session" 2>/dev/null || true
    tmux new-session -d -s "$session" -c "$worktree_dir"

    local color
    color="$(choose_random_color)"
    tmux set-option -t "$session" status-style "bg=$color,fg=black"
    tmux set-option -t "$session" status-interval 2
    tmux set-option -t "$session" status-left-length 80
    tmux set-option -t "$session" status-right-length 120
    tmux set-option -t "$session" status-left "#[fg=black,bold] #S "
    tmux set-option -t "$session" status-right "#[fg=black,bold]#(GWT_PANE_PATH='#{pane_current_path}' gwt tmux-status) "

    tmux rename-window -t "$session:0" "workspace"
    tmux split-window -t "$session:0" -h -c "$worktree_dir"

    local agent_command=""
    if [[ "$agent_override_set" -eq 1 ]]; then
        agent_command="$agent_override"
    else
        agent_command="${GWT_AGENT_COMMAND:-}"
    fi

    if [[ -n "$agent_command" ]]; then
        tmux send-keys -t "$session:0.0" "$agent_command" C-m
        tmux select-pane -t "$session:0.0"
    fi
    tmux send-keys -t "$session:0.1" "git status" C-m

    tmux attach-session -t "$session"
}

cmd_new() {
    require_git_repo
    require_command tmux
    local branch=""
    local base_branch=""
    local agent_override=""
    local agent_override_set=0
    local positionals=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --agent)
                if [[ $# -lt 2 ]]; then
                    echo "gwt new: --agent requires a command" >&2
                    exit 1
                fi
                agent_override="$2"
                agent_override_set=1
                shift 2
                ;;
            --agent=*)
                agent_override="${1#*=}"
                agent_override_set=1
                shift
                ;;
            --no-agent)
                agent_override=""
                agent_override_set=1
                shift
                ;;
            --)
                shift
                positionals+=("$@")
                break
                ;;
            --*)
                echo "gwt new: unknown option '$1'" >&2
                exit 1
                ;;
            *)
                positionals+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#positionals[@]} -lt 1 ]]; then
        echo "Usage: gwt new <branch> [base] [--agent CMD | --no-agent]" >&2
        exit 1
    fi

    branch="${positionals[0]}"
    if [[ ${#positionals[@]} -ge 2 ]]; then
        base_branch="${positionals[1]}"
    else
        base_branch="${GWT_BASE_BRANCH:-$DEFAULT_BASE_BRANCH}"
    fi

    create_worktree "$branch" "$base_branch"
    update_workspace_for_branch add "$branch"
    configure_tmux_session "$branch" "$agent_override" "$agent_override_set"
}

cmd_switch() {
    require_command tmux
    require_git_repo
    local branch="${1:-}"
    if [[ -z "$branch" ]]; then
        echo "Usage: gwt switch <branch>" >&2
        exit 1
    fi
    local session
    session="$(session_name_for_branch "$branch")"
    if tmux has-session -t "$session" 2>/dev/null; then
        tmux attach-session -t "$session"
        return
    fi

    local worktree_dir
    worktree_dir="$(existing_worktree_path_for_branch "$branch" || true)"
    if [[ -z "$worktree_dir" || ! -d "$worktree_dir" ]]; then
        echo "gwt: no tmux session found for $branch" >&2
        exit 1
    fi

    echo "gwt: worktree for $branch found at $worktree_dir but tmux session is missing" >&2
    read -r -p "Create a new tmux session? [y/N] " reply
    if [[ "$reply" =~ ^[Yy]$ ]]; then
        configure_tmux_session "$branch" "" 0
    else
        echo "gwt: not creating a new tmux session" >&2
        exit 1
    fi
}

cmd_list() {
    require_git_repo
    local repo
    repo="$(repo_name)"
    printf 'Worktrees\n---------\n'
    git worktree list | while read -r line; do
        local path branch session status
        path=$(echo "$line" | awk '{print $1}')
        branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')
        session="${repo}-${branch}"
        if tmux has-session -t "$session" 2>/dev/null; then
            status="✓ tmux"
        else
            status="✗ tmux"
        fi
        printf '%-25s %-8s %s\n' "$branch" "$status" "$path"
    done
    printf '\nSessions\n--------\n'
    tmux list-sessions 2>/dev/null | grep "^${repo}-" || echo 'none'
}

cmd_remove() {
    require_git_repo
    require_command tmux
    local branch="${1:-}"
    if [[ -z "$branch" ]]; then
        echo "Usage: gwt remove <branch>" >&2
        exit 1
    fi
    local worktree_dir session
    worktree_dir="$(worktree_path_for_branch "$branch")"
    session="$(session_name_for_branch "$branch")"
    echo "This will remove $worktree_dir and tmux session $session"
    read -r -p "Continue? [y/N] " reply
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        echo "aborted"
        exit 1
    fi
    tmux kill-session -t "$session" 2>/dev/null || true
    git worktree remove "$worktree_dir" --force
    update_workspace_for_branch remove "$branch"
    echo "✓ removed $branch"
}

cmd_cleanup() {
    require_git_repo
    local base="${1:-${GWT_BASE_BRANCH:-$DEFAULT_BASE_BRANCH}}"
    git fetch origin "$base" >/dev/null 2>&1 || true
    git worktree list | while read -r line; do
        local branch
        branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')
        if [[ "$branch" == "$base" || "$branch" == "main" || "$branch" == "master" ]]; then
            continue
        fi
        if git branch --merged "$base" | grep -F -x -q "${branch}"; then
            echo "✓ $branch merged into $base"
            read -r -p "  remove? [y/N] " reply
            if [[ "$reply" =~ ^[Yy]$ ]]; then
                cmd_remove "$branch"
            fi
        else
            echo "○ $branch not merged"
        fi
    done
}

cmd_status() {
    require_git_repo
    local current
    current=$(pwd)
    git worktree list | while read -r line; do
        local path branch
        path=$(echo "$line" | awk '{print $1}')
        branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')
        echo "→ $branch ($path)"
        if cd "$path" 2>/dev/null; then
            if [[ -n $(git status --porcelain) ]]; then
                echo "  ⚠ uncommitted changes"
                git status --short | sed 's/^/    /' | head -5
            else
                echo "  ✓ clean"
            fi
            local upstream
            upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)
            if [[ -n "$upstream" ]]; then
                local ahead behind
                ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo 0)
                behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo 0)
                if (( ahead > 0 || behind > 0 )); then
                    echo "  ↕ ahead:$ahead behind:$behind ($upstream)"
                fi
            else
                echo "  ○ no upstream"
            fi
        else
            echo "  ✗ cannot access"
        fi
        echo
    done
    cd "$current"
}

cmd_push() {
    require_git_repo
    local remote="${1:-origin}"
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD)
    echo "→ pushing $branch to $remote"
    git push -u "$remote" "$branch"
    if command -v gh >/dev/null 2>&1; then
        read -r -p "Create PR? [y/N] " reply
        if [[ "$reply" =~ ^[Yy]$ ]]; then
            gh pr create --web
        fi
    fi
}

cmd_from_pr() {
    require_git_repo
    if ! command -v gh >/dev/null 2>&1; then
        echo "gwt: GitHub CLI (gh) required" >&2
        exit 1
    fi
    local pr="${1:-}"
    if [[ -z "$pr" ]]; then
        echo "Usage: gwt from-pr <number>" >&2
        exit 1
    fi
    local branch
    branch=$(gh pr view "$pr" --json headRefName --jq '.headRefName')
    if [[ -z "$branch" ]]; then
        echo "gwt: unable to resolve PR #$pr" >&2
        exit 1
    fi
    git fetch origin "$branch"
    cmd_new "$branch"
}

format_sync_status() {
    local output=""
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    local main_branch=""
    if git show-ref --verify --quiet refs/heads/main; then
        main_branch="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        main_branch="master"
    fi
    if [[ -n "$main_branch" && "$branch" != "$main_branch" ]]; then
        local ahead behind
        ahead=$(git rev-list --count ${main_branch}..HEAD 2>/dev/null || echo 0)
        behind=$(git rev-list --count HEAD..${main_branch} 2>/dev/null || echo 0)
        if (( ahead > 0 || behind > 0 )); then
            output+=" [↑${ahead}↓${behind}]"
        fi
    fi
    local upstream
    upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)
    if [[ -n "$upstream" ]]; then
        local local_sha remote_sha
        local_sha=$(git rev-parse HEAD 2>/dev/null || echo 0)
        remote_sha=$(git rev-parse @{u} 2>/dev/null || echo 0)
        if [[ "$local_sha" == "$remote_sha" ]]; then
            output+=" ✓"
        else
            local ahead_remote behind_remote
            ahead_remote=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo 0)
            behind_remote=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo 0)
            if (( ahead_remote > 0 && behind_remote > 0 )); then
                output+=" ⟷${ahead_remote}/${behind_remote}"
            elif (( ahead_remote > 0 )); then
                output+=" →${ahead_remote}"
            elif (( behind_remote > 0 )); then
                output+=" ←${behind_remote}"
            fi
        fi
    else
        output+=" ⚠"
    fi
    echo "$output"
}

cmd_tmux_status() {
    local path="${GWT_PANE_PATH:-${1:-$PWD}}"
    if [[ ! -d "$path" ]]; then
        echo ""
        exit 0
    fi
    cd "$path" || exit 0
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo ""
        exit 0
    fi
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    local staged modified untracked
    staged=$(git diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
    modified=$(git diff --numstat 2>/dev/null | wc -l | tr -d ' ')
    untracked=$(git ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
    local status=""
    if (( staged > 0 )); then
        status+=" +${staged}"
    fi
    if (( modified > 0 )); then
        status+=" ~${modified}"
    fi
    if (( untracked > 0 )); then
        status+=" ?${untracked}"
    fi
    status="${status# }"
    local output="⎇ ${branch}"
    if [[ -n "$status" ]]; then
        output+=" [${status}]"
    fi
    output+="$(format_sync_status)"
    echo "$output"
}

print_completion_bash() {
    cat <<'EOS'
_gwt_branch_worktrees() {
    git worktree list 2>/dev/null | sed -n 's/.*\[\(.*\)\].*/\1/p'
}

_gwt_branch_locals() {
    git branch --format='%(refname:short)' 2>/dev/null
}

_gwt_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local cmd="${COMP_WORDS[1]}"

    if (( COMP_CWORD == 1 )); then
        COMPREPLY=( $(compgen -W "new switch list remove cleanup status push from-pr tmux-status agent config-path completion help" -- "$cur") )
        return
    fi

    case "$cmd" in
        switch|remove)
            local branches
            branches=$(_gwt_branch_worktrees)
            if [[ -n "$branches" ]]; then
                COMPREPLY=( $(compgen -W "$branches" -- "$cur") )
            fi
            ;;
        cleanup)
            local options
            options=$(printf '%s\n' main master develop $(_gwt_branch_locals) | sort -u)
            COMPREPLY=( $(compgen -W "$options" -- "$cur") )
            ;;
        new)
            local prev="${COMP_WORDS[COMP_CWORD-1]}"
            if [[ "$cur" == -* ]]; then
                COMPREPLY=( $(compgen -W "--agent --no-agent" -- "$cur") )
                return
            fi
            if [[ "$prev" == "--agent" ]]; then
                return
            fi
            if (( COMP_CWORD == 2 || COMP_CWORD == 3 )); then
                local options
                options=$(_gwt_branch_locals)
                if [[ -n "$options" ]]; then
                    COMPREPLY=( $(compgen -W "$options" -- "$cur") )
                fi
            fi
            ;;
        agent)
            if (( COMP_CWORD == 2 )); then
                COMPREPLY=( $(compgen -W "show set clear" -- "$cur") )
            fi
            ;;
        completion)
            if (( COMP_CWORD == 2 )); then
                COMPREPLY=( $(compgen -W "bash zsh" -- "$cur") )
            fi
            ;;
    esac
}

complete -o default -F _gwt_completion gwt
EOS
}

print_completion_zsh() {
    cat <<'EOS'
#compdef gwt

_gwt_branch_worktrees() {
    git worktree list 2>/dev/null | sed -n 's/.*\[\(.*\)\].*/\1/p'
}

_gwt_branch_locals() {
    git branch --format='%(refname:short)' 2>/dev/null
}

_gwt() {
    local -a commands
    commands=(
        'new:Create a worktree and tmux session'
        'switch:Attach to an existing session'
        'list:List worktrees and sessions'
        'remove:Remove a worktree and session'
        'cleanup:Prune merged worktrees'
        'status:Show summary of worktrees'
        'push:Push the current branch'
        'from-pr:Create worktree from PR'
        'tmux-status:Internal status helper'
        'agent:Manage agent command'
        'config-path:Show config file path'
        'completion:Print completion script'
        'help:Show usage'
    )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
        return
    fi

    local cmd=${words[2]}
    case $cmd in
        switch|remove)
            local -a branches
            branches=(${(f)"$(_gwt_branch_worktrees)"})
            _describe 'branch' branches
            ;;
        cleanup)
            local -a bases
            bases=(${(f)"$(printf '%s\n' main master develop $(_gwt_branch_locals) | sort -u)"})
            _describe 'branch' bases
            ;;
        new)
            local current_arg=${words[CURRENT]}
            local prev_arg=${words[CURRENT-1]}
            if [[ $current_arg == -* ]]; then
                local -a new_opts
                new_opts=(
                    '--agent:Set command to run in agent pane'
                    '--no-agent:Do not start an agent pane'
                )
                _describe 'option' new_opts
                return
            fi
            if [[ $prev_arg == --agent ]]; then
                return
            fi
            if (( CURRENT == 3 || CURRENT == 4 )); then
                local -a locals
                locals=(${(f)"$(_gwt_branch_locals)"})
                _describe 'branch' locals
            fi
            ;;
        agent)
            if (( CURRENT == 3 )); then
                local -a actions
                actions=(
                    'show:Print the configured agent command'
                    'set:Set the agent command'
                    'clear:Remove the agent command'
                )
                _describe 'agent action' actions
            fi
            ;;
        completion)
            if (( CURRENT == 3 )); then
                local -a shells
                shells=(
                    'bash:Bash completion script'
                    'zsh:Zsh completion script'
                )
                _describe 'shell' shells
            fi
            ;;
        *)
            _default
            ;;
    esac
}

compdef _gwt gwt
EOS
}

cmd_completion() {
    local shell="${1:-}"
    case "$shell" in
        bash)
            print_completion_bash
            ;;
        zsh)
            print_completion_zsh
            ;;
        "")
            echo "Usage: gwt completion <bash|zsh>" >&2
            exit 1
            ;;
        *)
            echo "gwt: unsupported shell '$shell'" >&2
            exit 1
            ;;
    esac
}

cmd_agent_show() {
    echo "${GWT_AGENT_COMMAND:-}"
}

cmd_agent_set() {
    local command="$*"
    if [[ -z "$command" ]]; then
        echo "Usage: gwt agent set <command>" >&2
        exit 1
    fi
    set_config_value GWT_AGENT_COMMAND "$command"
    GWT_AGENT_COMMAND="$command"
    echo "Agent command set to: $command"
}

cmd_agent_clear() {
    set_config_value GWT_AGENT_COMMAND ""
    unset GWT_AGENT_COMMAND || true
    echo "Agent command cleared"
}

cmd_config_path() {
    echo "$CONFIG_FILE"
}

main() {
    load_config
    ensure_config_dir
    local cmd="${1:-help}"
    shift || true
    case "$cmd" in
        new) cmd_new "$@" ;;
        switch) cmd_switch "$@" ;;
        list) cmd_list "$@" ;;
        remove) cmd_remove "$@" ;;
        cleanup) cmd_cleanup "$@" ;;
        status) cmd_status "$@" ;;
        push) cmd_push "$@" ;;
        from-pr) cmd_from_pr "$@" ;;
        tmux-status) cmd_tmux_status "$@" ;;
        agent)
            local sub="${1:-}"; shift || true
            case "$sub" in
                show) cmd_agent_show ;;
                set) cmd_agent_set "$@" ;;
                clear) cmd_agent_clear ;;
                *) echo "Usage: gwt agent {show|set|clear}" >&2; exit 1 ;;
            esac
            ;;
        completion) cmd_completion "$@" ;;
        config-path) cmd_config_path ;;
        help|-h|--help) print_usage ;;
        *) echo "Unknown command: $cmd" >&2; print_usage; exit 1 ;;
    esac
}

main "$@"
