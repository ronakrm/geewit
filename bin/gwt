#!/usr/bin/env bash
set -euo pipefail

readonly GWT_VERSION="0.1.1"

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/gwt"
CONFIG_FILE="${GWT_CONFIG_FILE:-$CONFIG_DIR/config}"

DEFAULT_BASE_BRANCH="main"
DEFAULT_COLORS=(red green yellow blue magenta cyan colour208 colour196 colour202 colour226 colour46 colour51 colour201 colour93 colour99 colour33 colour166 colour184 colour214 colour220)

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$CONFIG_FILE"
    fi
}

ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
}

# Session tracking infrastructure
SESSIONS_DIR="$CONFIG_DIR/sessions"
OUTPUT_DIR="$CONFIG_DIR/output"

ensure_sessions_dir() {
    mkdir -p "$SESSIONS_DIR"
}

ensure_output_dir() {
    mkdir -p "$OUTPUT_DIR"
}

sessions_file_for_repo() {
    local repo
    repo="$(repo_name)"
    echo "$SESSIONS_DIR/${repo}.json"
}

get_session_data() {
    local branch="$1"
    local sessions_file
    sessions_file="$(sessions_file_for_repo)"
    if [[ -f "$sessions_file" ]]; then
        python3 -c "
import json
import sys
try:
    with open('$sessions_file', 'r') as f:
        data = json.load(f)
    result = data.get('$branch', {})
    print(json.dumps(result))
except (json.JSONDecodeError, FileNotFoundError):
    print('{}')
"
    else
        echo '{}'
    fi
}

set_session_data() {
    local branch="$1"
    local key="$2"
    local value="$3"
    ensure_sessions_dir
    local sessions_file
    sessions_file="$(sessions_file_for_repo)"
    python3 -c "
import json
import os

sessions_file = '$sessions_file'
branch = '$branch'
key = '$key'
value = '$value'

# Load existing data
data = {}
if os.path.exists(sessions_file):
    try:
        with open(sessions_file, 'r') as f:
            data = json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        data = {}

# Initialize branch if needed
if branch not in data:
    data[branch] = {}

# Set the key
data[branch][key] = value

# Write back
with open(sessions_file, 'w') as f:
    json.dump(data, f, indent=2)
    f.write('\n')
"
}

generate_session_uuid() {
    local branch="$1"
    local repo
    repo="$(repo_name)"
    # Use uuid5 with DNS namespace + repo + branch for deterministic ID
    python3 -c "import uuid; print(uuid.uuid5(uuid.NAMESPACE_DNS, '$repo-$branch'))"
}

remove_session_data() {
    local branch="$1"
    local sessions_file
    sessions_file="$(sessions_file_for_repo)"
    if [[ ! -f "$sessions_file" ]]; then
        return
    fi
    python3 -c "
import json
import os

sessions_file = '$sessions_file'
branch = '$branch'

data = {}
try:
    with open(sessions_file, 'r') as f:
        data = json.load(f)
except (json.JSONDecodeError, FileNotFoundError):
    data = {}

if branch in data:
    del data[branch]
    with open(sessions_file, 'w') as f:
        json.dump(data, f, indent=2)
        f.write('\n')
"
}

set_config_value() {
    local key="$1"
    local value="$2"
    ensure_config_dir
    touch "$CONFIG_FILE"
    local escaped
    escaped=$(printf '%q' "$value")
    local escaped_sed
    escaped_sed="${escaped//\\/\\\\}"
    escaped_sed="${escaped_sed//&/\\&}"
    if grep -q "^${key}=" "$CONFIG_FILE"; then
        sed -i "s|^${key}=.*$|${key}=${escaped_sed}|" "$CONFIG_FILE"
    else
        printf '%s=%s\n' "$key" "$escaped" >> "$CONFIG_FILE"
    fi
}

print_usage() {
    cat <<'EOS'
Usage: gwt [--repo-path <path>] <command> [args]

Core commands
  new <branch> [base]     Create a worktree + tmux session (base defaults to main)
                          Options:
                            --agent CMD       Override agent command
                            --no-agent        Skip agent entirely
                            --detach, -d      Create without attaching
                            --headless, -H    Run agent headlessly (no tmux)
                            --no-user-pane    Single pane with agent only
                            --no-agent-pane   Single pane with user only
  switch <branch>         Attach to an existing session
  list                    List worktrees and matching tmux sessions
  remove <branch>         Remove worktree, tmux session, and local branch
                          Use --keep-branch to preserve the local branch
  cleanup [base]          Remove worktrees already merged into base (default: main)
  merge <branch> [base]   Merge branch into base and clean up the worktree
  status                  Show git status for every worktree
  push [remote]           Push current branch (default remote: origin)
  from-pr <number>        Create a worktree from a GitHub PR (requires gh)
  info <branch>           Show comprehensive branch status (parseable key=value)
  sessions                List all tracked Claude sessions

Tmux integration
  tmux-status [path]      Internal helper for the tmux status line

Agent commands
  agent show              Show current agent command
  agent set <command>     Update the command used to start the agent pane
  agent clear             Remove the agent command
  agent send <branch> <msg>    Send message to agent
  agent output <branch>        View agent output (--raw for raw json)
  agent attach <branch>        Attach to agent in tmux (resumes conversation)
  agent status [branch]        Show agent status
  agent clear-session <branch> Clear session ID for fresh start

Other
  config-path             Print the config file location
  completion <shell>      Print shell completion script (bash|zsh)
  version                 Show CLI version
  help                    Show this message
EOS
}

require_git_repo() {
    if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
        echo "gwt: must be run inside a git repository" >&2
        exit 1
    fi
}

require_command() {
    local cmd="$1"
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "gwt: missing required command '$cmd'" >&2
        exit 1
    fi
}

repo_root() {
    git rev-parse --show-toplevel
}

primary_worktree_root() {
    local common
    common=$(git rev-parse --path-format=absolute --git-common-dir 2>/dev/null || true)
    if [[ -z "$common" ]]; then
        return
    fi
    if [[ -d "$common" ]]; then
        dirname "$common"
    fi
}

canonical_repo_root() {
    local primary
    primary="$(primary_worktree_root)"
    if [[ -n "$primary" ]]; then
        echo "$primary"
    else
        repo_root
    fi
}

repo_name() {
    basename "$(canonical_repo_root)"
}

resolve_worktree_base() {
    local root="$1"
    local base="${GWT_WORKTREE_BASE:-}"
    if [[ -z "$base" ]]; then
        base="$(cd "$root/.." && pwd)"
    elif [[ "${base:0:1}" != "/" ]]; then
        mkdir -p "$root/$base"
        base="$(cd "$root/$base" && pwd)"
    else
        mkdir -p "$base"
    fi
    echo "$base"
}

worktree_path_for_branch() {
    local branch="$1"
    local root
    root="$(canonical_repo_root)"
    local base
    base="$(resolve_worktree_base "$root")"
    local prefix="${GWT_PREFIX:-}"
    local path
    path="$base/${prefix}$(repo_name)-$branch"
    echo "$path"
}

worktree_dir_for_branch() {
    local branch="$1"
    local current=""
    local path=""
    while IFS= read -r line; do
        case "$line" in
            "worktree "*)
                current="${line#worktree }"
                ;;
            "branch refs/heads/$branch")
                if [[ -n "$current" ]]; then
                    path="$current"
                    break
                fi
                ;;
        esac
    done < <(git worktree list --porcelain)
    if [[ -n "$path" ]]; then
        echo "$path"
        return
    fi
    local fallback
    fallback="$(worktree_path_for_branch "$branch")"
    if [[ -n "$fallback" && -d "$fallback" ]]; then
        echo "$fallback"
    fi
}

ensure_worktree_clean() {
    local dir="$1"
    local label="${2:-$dir}"
    if [[ -z "$dir" || ! -d "$dir" ]]; then
        return
    fi
    local status
    status="$(git -C "$dir" status --porcelain 2>/dev/null || true)"
    if [[ -n "$status" ]]; then
        echo "gwt: worktree '$label' has uncommitted changes" >&2
        exit 1
    fi
}

remove_branch_resources() {
    local branch="$1"
    local repo_dir
    repo_dir="$(canonical_repo_root)"
    local worktree_dir
    worktree_dir="$(worktree_dir_for_branch "$branch")"
    local session
    session="$(session_name_for_branch "$branch")"

    if [[ -n "$worktree_dir" && -d "$worktree_dir" && "$worktree_dir" != "$repo_dir" ]]; then
        git -C "$repo_dir" worktree remove "$worktree_dir" --force >/dev/null 2>&1 || true
    fi
    if command -v tmux >/dev/null 2>&1; then
        tmux kill-session -t "$session" 2>/dev/null || true
    fi
    update_workspace_for_branch remove "$branch"
}

session_name_for_branch() {
    printf '%s-%s' "$(repo_name)" "$1"
}

copy_env_if_present() {
    local root
    root="$(canonical_repo_root)"
    local worktree_dir="$1"
    if [[ -f "$root/.env" ]]; then
        cp "$root/.env" "$worktree_dir/.env"
    fi
}

get_hook_script_path() {
    local hook_name="$1"
    local root
    root="$(canonical_repo_root)"
    local script_path="$root/.geewit_${hook_name}.sh"
    if [[ -f "$script_path" && -x "$script_path" ]]; then
        echo "$script_path"
    fi
}

find_workspace_file() {
    local root
    root="$(canonical_repo_root)"
    find "$root" -maxdepth 1 -type f -name '*.code-workspace' -print -quit 2>/dev/null || true
}

update_workspace_for_branch() {
    local action="$1"
    local branch="$2"
    local workspace_file
    workspace_file="$(find_workspace_file)"
    if [[ -z "$workspace_file" ]]; then
        return
    fi
    if ! command -v python3 >/dev/null 2>&1; then
        echo "gwt: python3 required to update workspace file" >&2
        return
    fi
    local worktree_dir
    worktree_dir="$(worktree_path_for_branch "$branch")"
    python3 - "$workspace_file" "$worktree_dir" "$action" <<'PY'
import json
import os
import sys

workspace_file, worktree_dir, action = sys.argv[1:4]

try:
    with open(workspace_file, 'r', encoding='utf-8') as handle:
        data = json.load(handle)
except (OSError, json.JSONDecodeError):
    sys.exit(0)

if not isinstance(data, dict):
    sys.exit(0)

folders = data.get('folders')
if not isinstance(folders, list):
    folders = []
    data['folders'] = folders

workspace_root = os.path.dirname(workspace_file) or os.curdir
rel_path = os.path.relpath(worktree_dir, workspace_root)
rel_path = rel_path.replace(os.path.sep, '/')
abs_path = os.path.abspath(worktree_dir).replace(os.path.sep, '/')

def normalise(value):
    return (value or '').replace('\\', '/')

targets = {normalise(rel_path), normalise(abs_path)}

changed = False

if action == 'add':
    for folder in folders:
        if isinstance(folder, dict) and normalise(folder.get('path')) in targets:
            break
    else:
        folders.append({'path': rel_path})
        changed = True
elif action == 'remove':
    new_folders = []
    for folder in folders:
        if isinstance(folder, dict) and normalise(folder.get('path')) in targets:
            changed = True
            continue
        new_folders.append(folder)
    if changed:
        data['folders'] = new_folders

if changed:
    with open(workspace_file, 'w', encoding='utf-8') as handle:
        json.dump(data, handle, indent=4)
        handle.write('\n')
PY
}

choose_random_color() {
    local idx=$((RANDOM % ${#DEFAULT_COLORS[@]}))
    echo "${DEFAULT_COLORS[$idx]}"
}

branch_exists_locally() {
    git show-ref --quiet --verify "refs/heads/$1"
}

branch_exists_remote() {
    git ls-remote --exit-code --heads origin "$1" >/dev/null 2>&1
}

resolve_base_revision() {
    local base="$1"
    local commit=""

    if commit=$(git rev-parse --verify --quiet "${base}^{commit}"); then
        echo "$commit"
        return
    fi

    if [[ "$base" != */* ]]; then
        if commit=$(git rev-parse --verify --quiet "origin/${base}^{commit}"); then
            echo "$commit"
            return
        fi

        if git fetch origin "$base" >/dev/null 2>&1; then
            if commit=$(git rev-parse --verify --quiet "origin/${base}^{commit}"); then
                echo "$commit"
                return
            fi
        fi
    fi

    echo "gwt: unable to resolve base branch '$base'" >&2
    exit 1
}

create_worktree() {
    local branch="$1"
    local base_branch="$2"
    local worktree_dir
    worktree_dir="$(worktree_path_for_branch "$branch")"

    echo "→ creating worktree at $worktree_dir"
    if branch_exists_locally "$branch" || branch_exists_remote "$branch"; then
        git worktree add "$worktree_dir" "$branch"
    else
        local base_revision
        base_revision="$(resolve_base_revision "$base_branch")"
        git worktree add -b "$branch" "$worktree_dir" "$base_revision"
    fi
    copy_env_if_present "$worktree_dir"
}

setup_tmux_session_base() {
    local branch="$1"
    local worktree_dir="$2"
    local session
    session="$(session_name_for_branch "$branch")"

    tmux kill-session -t "$session" 2>/dev/null || true
    tmux new-session -d -s "$session" -c "$worktree_dir"

    local color
    color="$(choose_random_color)"
    tmux set-option -t "$session" status-style "bg=$color,fg=black"
    tmux set-option -t "$session" status-interval 2
    tmux set-option -t "$session" status-left-length 80
    tmux set-option -t "$session" status-right-length 120
    tmux set-option -t "$session" status-left "#[fg=black,bold] #S "
    tmux set-option -t "$session" status-right "#[fg=black,bold]#(GWT_PANE_PATH='#{pane_current_path}' gwt tmux-status) "

    tmux rename-window -t "$session:0" "workspace"
    tmux split-window -t "$session:0" -h -c "$worktree_dir"
}

attach_tmux_session() {
    local session="$1"
    if [[ -n "${TMUX:-}" ]]; then
        tmux switch-client -t "$session"
    else
        tmux attach-session -t "$session"
    fi
}

# Initialize headless agent tracking (no process started - uses -p --resume per message)
init_headless_agent() {
    local branch="$1"
    local worktree_dir="$2"
    local session_uuid
    session_uuid="$(generate_session_uuid "$branch")"

    local repo
    repo="$(repo_name)"
    ensure_output_dir
    local output_file="$OUTPUT_DIR/${repo}-${branch}.log"

    # Save session data (no PID since we use -p --resume per message)
    set_session_data "$branch" "session_id" "$session_uuid"
    set_session_data "$branch" "mode" "headless"
    set_session_data "$branch" "output_file" "$output_file"
    set_session_data "$branch" "worktree" "$worktree_dir"
    set_session_data "$branch" "started_at" "$(date -Iseconds)"

    echo "✓ initialized headless agent (session: $session_uuid)"
    echo "  worktree: $worktree_dir"
    echo "  send messages: gwt agent send $branch 'your message'"
}

configure_tmux_session() {
    local branch="$1"
    local agent_override="${2:-}"
    local agent_override_set="${3:-0}"
    local detach="${4:-0}"
    local no_user_pane="${5:-0}"
    local no_agent_pane="${6:-0}"
    local worktree_dir
    worktree_dir="$(worktree_path_for_branch "$branch")"
    local session
    session="$(session_name_for_branch "$branch")"

    # Kill existing session
    tmux kill-session -t "$session" 2>/dev/null || true
    tmux new-session -d -s "$session" -c "$worktree_dir"

    # Style setup
    local color
    color="$(choose_random_color)"
    tmux set-option -t "$session" status-style "bg=$color,fg=black"
    tmux set-option -t "$session" status-interval 2
    tmux set-option -t "$session" status-left-length 80
    tmux set-option -t "$session" status-right-length 120
    tmux set-option -t "$session" status-left "#[fg=black,bold] #S "
    tmux set-option -t "$session" status-right "#[fg=black,bold]#(GWT_PANE_PATH='#{pane_current_path}' gwt tmux-status) "

    tmux rename-window -t "$session:0" "workspace"

    # Only split if we need both panes
    if (( !no_user_pane && !no_agent_pane )); then
        tmux split-window -t "$session:0" -h -c "$worktree_dir"
    fi

    # Determine agent command
    local agent_command=""
    if (( !no_agent_pane )); then
        if [[ "$agent_override_set" -eq 1 ]]; then
            agent_command="$agent_override"
        else
            agent_command="${GWT_AGENT_COMMAND:-}"
        fi
    fi

    # Track Claude session
    local session_uuid
    session_uuid="$(generate_session_uuid "$branch")"

    if [[ -n "$agent_command" ]]; then
        # Inject session ID into agent command if it's Claude
        if [[ "$agent_command" == claude* ]]; then
            agent_command="$agent_command --session-id $session_uuid"
        fi
        tmux send-keys -t "$session:0.0" "$agent_command" C-m
        tmux select-pane -t "$session:0.0"
        set_session_data "$branch" "session_id" "$session_uuid"
        set_session_data "$branch" "mode" "tmux"
        set_session_data "$branch" "worktree" "$worktree_dir"
        set_session_data "$branch" "started_at" "$(date -Iseconds)"
    fi

    # User pane setup
    if (( !no_user_pane )); then
        local user_pane="$session:0.1"
        if (( no_agent_pane )); then
            user_pane="$session:0.0"
        fi
        tmux send-keys -t "$user_pane" "git status" C-m

        local hook_script
        hook_script="$(get_hook_script_path "new")"
        if [[ -n "$hook_script" ]]; then
            tmux send-keys -t "$user_pane" "source $hook_script" C-m
        fi
    fi

    if (( detach )); then
        echo "✓ created session $session (use 'gwt switch $branch' to attach)"
    else
        attach_tmux_session "$session"
    fi
}

configure_tmux_session_recovery() {
    local branch="$1"
    local worktree_dir="$2"
    local session
    session="$(session_name_for_branch "$branch")"

    setup_tmux_session_base "$branch" "$worktree_dir"

    # Show recovery message instead of starting agent
    tmux send-keys -t "$session:0.0" "echo '⚠ Recovered session - resume agent manually if desired'" C-m
    tmux send-keys -t "$session:0.1" "git status" C-m

    attach_tmux_session "$session"
}

cmd_new() {
    require_git_repo
    local branch=""
    local base_branch=""
    local agent_override=""
    local agent_override_set=0
    local detach=0
    local headless=0
    local no_user_pane=0
    local no_agent_pane=0
    local positionals=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --agent)
                if [[ $# -lt 2 ]]; then
                    echo "gwt new: --agent requires a command" >&2
                    exit 1
                fi
                agent_override="$2"
                agent_override_set=1
                shift 2
                ;;
            --agent=*)
                agent_override="${1#*=}"
                agent_override_set=1
                shift
                ;;
            --no-agent)
                agent_override=""
                agent_override_set=1
                shift
                ;;
            --detach|-d)
                detach=1
                shift
                ;;
            --headless|-H)
                headless=1
                shift
                ;;
            --no-user-pane)
                no_user_pane=1
                shift
                ;;
            --no-agent-pane)
                no_agent_pane=1
                agent_override=""
                agent_override_set=1
                shift
                ;;
            --)
                shift
                positionals+=("$@")
                break
                ;;
            --*)
                echo "gwt new: unknown option '$1'" >&2
                exit 1
                ;;
            *)
                positionals+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#positionals[@]} -lt 1 ]]; then
        echo "Usage: gwt new <branch> [base] [options]" >&2
        echo "Options: --agent CMD, --no-agent, --detach/-d, --headless/-H, --no-user-pane, --no-agent-pane" >&2
        exit 1
    fi

    # Headless mode doesn't need tmux
    if (( !headless )); then
        require_command tmux
    fi

    branch="${positionals[0]}"
    if [[ ${#positionals[@]} -ge 2 ]]; then
        base_branch="${positionals[1]}"
    else
        base_branch="${GWT_BASE_BRANCH:-$DEFAULT_BASE_BRANCH}"
    fi

    local session
    session="$(session_name_for_branch "$branch")"
    local worktree_dir
    worktree_dir="$(worktree_dir_for_branch "$branch")"

    # Check if worktree exists but session is missing (orphaned worktree)
    if [[ -n "$worktree_dir" && -d "$worktree_dir" ]]; then
        if (( headless )); then
            # For headless mode, check if already tracked
            local existing_data
            existing_data="$(get_session_data "$branch")"
            if [[ -n "$existing_data" && "$existing_data" != "{}" ]]; then
                echo "gwt: headless agent already exists for $branch" >&2
                echo "Use 'gwt agent send $branch <message>' to send messages" >&2
                exit 1
            fi
            # Worktree exists but not tracked as headless, set it up
            init_headless_agent "$branch" "$worktree_dir"
            return
        elif ! tmux has-session -t "$session" 2>/dev/null; then
            echo "gwt: worktree already exists at $worktree_dir but tmux session is missing"
            read -r -p "Create new tmux session for this worktree? [y/N] " reply
            if [[ "$reply" =~ ^[Yy]$ ]]; then
                configure_tmux_session_recovery "$branch" "$worktree_dir"
                return
            else
                echo "aborted"
                exit 1
            fi
        else
            echo "gwt: worktree and session already exist for $branch" >&2
            echo "Use 'gwt switch $branch' to attach to the existing session" >&2
            exit 1
        fi
    fi

    create_worktree "$branch" "$base_branch"
    update_workspace_for_branch add "$branch"

    if (( headless )); then
        local new_worktree_dir
        new_worktree_dir="$(worktree_path_for_branch "$branch")"
        init_headless_agent "$branch" "$new_worktree_dir"
    else
        configure_tmux_session "$branch" "$agent_override" "$agent_override_set" "$detach" "$no_user_pane" "$no_agent_pane"
    fi
}

cmd_switch() {
    require_command tmux
    require_git_repo
    local branch="${1:-}"
    if [[ -z "$branch" ]]; then
        echo "Usage: gwt switch <branch>" >&2
        exit 1
    fi

    # Check for headless agent first
    local data
    data="$(get_session_data "$branch")"
    local mode
    mode=$(echo "$data" | python3 -c "import json,sys; print(json.load(sys.stdin).get('mode',''))" 2>/dev/null)

    if [[ "$mode" == "headless" ]]; then
        echo "gwt: branch $branch has a headless agent"
        read -r -p "Attach to agent in tmux? [y/N] " reply
        if [[ "$reply" =~ ^[Yy]$ ]]; then
            cmd_agent_attach "$branch"
            return
        fi
        # If user declines, fall through to regular handling
    fi

    local session
    session="$(session_name_for_branch "$branch")"
    if tmux has-session -t "$session" 2>/dev/null; then
        if [[ -n "${TMUX:-}" ]]; then
            tmux switch-client -t "$session"
        else
            tmux attach-session -t "$session"
        fi
    else
        # Check if worktree exists but session is missing (orphaned worktree)
        local worktree_dir
        worktree_dir="$(worktree_dir_for_branch "$branch")"
        if [[ -n "$worktree_dir" && -d "$worktree_dir" ]]; then
            echo "gwt: worktree exists at $worktree_dir but tmux session is missing"
            read -r -p "Create new tmux session for this worktree? [y/N] " reply
            if [[ "$reply" =~ ^[Yy]$ ]]; then
                configure_tmux_session_recovery "$branch" "$worktree_dir"
            else
                echo "aborted"
                exit 1
            fi
        else
            echo "gwt: no tmux session found for $branch" >&2
            exit 1
        fi
    fi
}

cmd_list() {
    require_git_repo
    local repo
    repo="$(repo_name)"
    printf 'Worktrees\n---------\n'
    git worktree list | while read -r line; do
        local path branch session status
        path=$(echo "$line" | awk '{print $1}')
        branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')
        session="${repo}-${branch}"
        if tmux has-session -t "$session" 2>/dev/null; then
            status="✓ tmux"
        else
            status="✗ tmux"
        fi
        printf '%-25s %-8s %s\n' "$branch" "$status" "$path"
    done
    printf '\nSessions\n--------\n'
    tmux list-sessions 2>/dev/null | grep "^${repo}-" || echo 'none'
}

cmd_remove() {
    require_git_repo
    require_command tmux
    local branch=""
    local keep_branch=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --keep-branch)
                keep_branch=1
                shift
                ;;
            --)
                shift
                if [[ $# -gt 0 ]]; then
                    branch="$1"
                fi
                break
                ;;
            --*)
                echo "gwt remove: unknown option '$1'" >&2
                exit 1
                ;;
            *)
                branch="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$branch" ]]; then
        echo "Usage: gwt remove <branch> [--keep-branch]" >&2
        exit 1
    fi
    local worktree_dir session
    worktree_dir="$(worktree_path_for_branch "$branch")"
    session="$(session_name_for_branch "$branch")"
    local repo_dir
    repo_dir="$(canonical_repo_root)"
    echo "This will remove $worktree_dir, tmux session $session, and local branch $branch"
    if (( keep_branch )); then
        echo "(--keep-branch: local branch will be preserved)"
    fi
    read -r -p "Continue? [y/N] " reply
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        echo "aborted"
        exit 1
    fi
    local hook_script
    hook_script="$(get_hook_script_path "remove")"
    if [[ -n "$hook_script" && -d "$worktree_dir" ]]; then
        if tmux has-session -t "$session" 2>/dev/null; then
            echo "→ running remove hook in tmux pane"
            tmux send-keys -t "$session:0.1" C-c C-c
            local wait_channel="gwt-remove-$$"
            local hook_command
            printf -v hook_command 'cd "%s" && ( source "%s" ) || true; tmux wait-for -S "%s"' \
                "$worktree_dir" "$hook_script" "$wait_channel"
            tmux send-keys -t "$session:0.1" "$hook_command" C-m
            tmux wait-for "$wait_channel"
        else
            echo "→ running remove hook"
            (cd "$worktree_dir" && "$hook_script")
        fi
    fi
    tmux kill-session -t "$session" 2>/dev/null || true
    git worktree remove "$worktree_dir" --force
    update_workspace_for_branch remove "$branch"

    # Clean up session tracking data
    remove_session_data "$branch"

    if (( keep_branch )); then
        echo "✓ removed worktree and session for $branch (branch preserved)"
    else
        if git -C "$repo_dir" branch -d "$branch" 2>/dev/null; then
            echo "✓ removed $branch"
        elif git -C "$repo_dir" branch -D "$branch" 2>/dev/null; then
            echo "✓ removed $branch (force deleted unmerged branch)"
        else
            echo "✓ removed worktree and session (branch $branch not found or could not be deleted)"
        fi
    fi
}

cmd_cleanup() {
    require_git_repo
    local base="${1:-${GWT_BASE_BRANCH:-$DEFAULT_BASE_BRANCH}}"
    git fetch origin "$base" >/dev/null 2>&1 || true
    git worktree list | while read -r line; do
        local branch
        branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')
        if [[ "$branch" == "$base" || "$branch" == "main" || "$branch" == "master" ]]; then
            continue
        fi
        if git branch --merged "$base" | grep -F -x -q "${branch}"; then
            echo "✓ $branch merged into $base"
            read -r -p "  remove? [y/N] " reply
            if [[ "$reply" =~ ^[Yy]$ ]]; then
                cmd_remove "$branch"
            fi
        else
            echo "○ $branch not merged"
        fi
    done
}

cmd_merge() {
    require_git_repo
    local keep_resources=0
    local positionals=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --keep)
                keep_resources=1
                shift
                ;;
            --)
                shift
                while [[ $# -gt 0 ]]; do
                    positionals+=("$1")
                    shift
                done
                break
                ;;
            --*)
                echo "gwt merge: unknown option '$1'" >&2
                exit 1
                ;;
            *)
                positionals+=("$1")
                shift
                ;;
        esac
    done

    local branch=""
    local base=""
    if (( ${#positionals[@]} >= 1 )); then
        branch="${positionals[0]}"
    fi
    if (( ${#positionals[@]} >= 2 )); then
        base="${positionals[1]}"
    fi

    if [[ -z "$branch" ]]; then
        branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
    fi
    if [[ -z "$branch" ]]; then
        echo "gwt merge: unable to determine branch to merge" >&2
        exit 1
    fi
    if [[ -z "$base" ]]; then
        base="${GWT_BASE_BRANCH:-$DEFAULT_BASE_BRANCH}"
    fi
    if [[ "$branch" == "$base" ]]; then
        echo "gwt merge: branch and base are identical ($branch)" >&2
        exit 1
    fi

    if ! git rev-parse --verify --quiet "refs/heads/$branch" >/dev/null; then
        echo "gwt merge: unknown branch '$branch'" >&2
        exit 1
    fi

    local repo_dir
    repo_dir="$(canonical_repo_root)"

    if ! git rev-parse --verify --quiet "refs/heads/$base" >/dev/null; then
        local base_commit=""
        base_commit="$(resolve_base_revision "$base")"
        git -C "$repo_dir" branch --track "$base" "$base_commit" >/dev/null 2>&1 || \
            git -C "$repo_dir" branch "$base" "$base_commit" >/dev/null 2>&1 || true
    fi

    ensure_worktree_clean "$repo_dir" "$base"

    local branch_dir
    branch_dir="$(worktree_dir_for_branch "$branch")"
    ensure_worktree_clean "$branch_dir" "$branch"

    git -C "$repo_dir" fetch origin "$base" >/dev/null 2>&1 || true

    if ! git -C "$repo_dir" switch "$base" >/dev/null 2>&1; then
        git -C "$repo_dir" checkout "$base" >/dev/null 2>&1 || true
    fi

    echo "→ merging $branch into $base"
    if ! git -C "$repo_dir" merge --no-ff "$branch"; then
        echo "⚠ merge conflict detected while merging $branch into $base" >&2
        echo "   Resolve conflicts in $repo_dir, commit, then rerun 'gwt merge $branch $base'." >&2
        echo "   Tip: use 'gwt switch $branch' to jump back into the branch worktree." >&2
        return 1
    fi

    echo "✓ merged $branch into $base"

    if (( keep_resources )); then
        return 0
    fi

    remove_branch_resources "$branch"
    if git -C "$repo_dir" branch -d "$branch"; then
        echo "✓ deleted branch $branch"
    else
        echo "⚠ could not delete branch $branch (is it still checked out?)" >&2
    fi
}

cmd_status() {
    require_git_repo
    local current
    current=$(pwd)
    git worktree list | while read -r line; do
        local path branch
        path=$(echo "$line" | awk '{print $1}')
        branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')
        echo "→ $branch ($path)"
        if cd "$path" 2>/dev/null; then
            if [[ -n $(git status --porcelain) ]]; then
                echo "  ⚠ uncommitted changes"
                git status --short | sed 's/^/    /' | head -5
            else
                echo "  ✓ clean"
            fi
            local upstream
            upstream=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null || true)
            if [[ -n "$upstream" ]]; then
                local ahead behind
                ahead=$(git rev-list --count '@{u}..HEAD' 2>/dev/null || echo 0)
                behind=$(git rev-list --count 'HEAD..@{u}' 2>/dev/null || echo 0)
                if (( ahead > 0 || behind > 0 )); then
                    echo "  ↕ ahead:$ahead behind:$behind ($upstream)"
                fi
            else
                echo "  ○ no upstream"
            fi
        else
            echo "  ✗ cannot access"
        fi
        echo
    done
    cd "$current"
}

cmd_push() {
    require_git_repo
    local remote="${1:-origin}"
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD)
    echo "→ pushing $branch to $remote"
    git push -u "$remote" "$branch"
    if command -v gh >/dev/null 2>&1; then
        read -r -p "Create PR? [y/N] " reply
        if [[ "$reply" =~ ^[Yy]$ ]]; then
            gh pr create --web
        fi
    fi
}

cmd_from_pr() {
    require_git_repo
    if ! command -v gh >/dev/null 2>&1; then
        echo "gwt: GitHub CLI (gh) required" >&2
        exit 1
    fi
    local pr="${1:-}"
    if [[ -z "$pr" ]]; then
        echo "Usage: gwt from-pr <number>" >&2
        exit 1
    fi
    local branch
    branch=$(gh pr view "$pr" --json headRefName --jq '.headRefName')
    if [[ -z "$branch" ]]; then
        echo "gwt: unable to resolve PR #$pr" >&2
        exit 1
    fi
    git fetch origin "$branch"
    cmd_new "$branch"
}

format_sync_status() {
    local output=""
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    local main_branch=""
    if git show-ref --verify --quiet refs/heads/main; then
        main_branch="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        main_branch="master"
    fi
    if [[ -n "$main_branch" && "$branch" != "$main_branch" ]]; then
        local ahead behind
        ahead=$(git rev-list --count ${main_branch}..HEAD 2>/dev/null || echo 0)
        behind=$(git rev-list --count HEAD..${main_branch} 2>/dev/null || echo 0)
        if (( ahead > 0 || behind > 0 )); then
            output+=" [↑${ahead}↓${behind}]"
        fi
    fi
    local upstream
    upstream=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null || true)
    if [[ -n "$upstream" ]]; then
        local local_sha remote_sha
        local_sha=$(git rev-parse HEAD 2>/dev/null || echo 0)
        remote_sha=$(git rev-parse '@{u}' 2>/dev/null || echo 0)
        if [[ "$local_sha" == "$remote_sha" ]]; then
            output+=" ✓"
        else
            local ahead_remote behind_remote
            ahead_remote=$(git rev-list --count '@{u}..HEAD' 2>/dev/null || echo 0)
            behind_remote=$(git rev-list --count 'HEAD..@{u}' 2>/dev/null || echo 0)
            if (( ahead_remote > 0 && behind_remote > 0 )); then
                output+=" ⟷${ahead_remote}/${behind_remote}"
            elif (( ahead_remote > 0 )); then
                output+=" →${ahead_remote}"
            elif (( behind_remote > 0 )); then
                output+=" ←${behind_remote}"
            fi
        fi
    else
        output+=" ⚠"
    fi
    echo "$output"
}

cmd_tmux_status() {
    local path="${GWT_PANE_PATH:-${1:-$PWD}}"
    if [[ ! -d "$path" ]]; then
        echo ""
        exit 0
    fi
    cd "$path" || exit 0
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo ""
        exit 0
    fi
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    local staged modified untracked
    staged=$(git diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
    modified=$(git diff --numstat 2>/dev/null | wc -l | tr -d ' ')
    untracked=$(git ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')
    local status=""
    if (( staged > 0 )); then
        status+=" +${staged}"
    fi
    if (( modified > 0 )); then
        status+=" ~${modified}"
    fi
    if (( untracked > 0 )); then
        status+=" ?${untracked}"
    fi
    status="${status# }"
    local output="⎇ ${branch}"
    if [[ -n "$status" ]]; then
        output+=" [${status}]"
    fi
    output+="$(format_sync_status)"
    echo "$output"
}

print_completion_bash() {
    cat <<'EOS'
_gwt_branch_worktrees() {
    git worktree list 2>/dev/null | sed -n 's/.*\[\(.*\)\].*/\1/p'
}

_gwt_branch_locals() {
    git branch --format='%(refname:short)' 2>/dev/null
}

_gwt_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local cmd="${COMP_WORDS[1]}"

    if (( COMP_CWORD == 1 )); then
        COMPREPLY=( $(compgen -W "new switch list remove cleanup merge status push from-pr tmux-status agent info sessions config-path completion version help" -- "$cur") )
        return
    fi

    case "$cmd" in
        switch)
            local branches
            branches=$(_gwt_branch_worktrees)
            if [[ -n "$branches" ]]; then
                COMPREPLY=( $(compgen -W "$branches" -- "$cur") )
            fi
            ;;
        remove)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=( $(compgen -W "--keep-branch" -- "$cur") )
                return
            fi
            local branches
            branches=$(_gwt_branch_worktrees)
            if [[ -n "$branches" ]]; then
                COMPREPLY=( $(compgen -W "$branches" -- "$cur") )
            fi
            ;;
        cleanup)
            local options
            options=$(printf '%s\n' main master develop $(_gwt_branch_locals) | sort -u)
            COMPREPLY=( $(compgen -W "$options" -- "$cur") )
            ;;
        merge)
            local prev="${COMP_WORDS[COMP_CWORD-1]}"
            if [[ "$cur" == -* ]]; then
                COMPREPLY=( $(compgen -W "--keep" -- "$cur") )
                return
            fi
            if [[ "$prev" == "--keep" ]]; then
                local branches
                branches=$(_gwt_branch_locals)
                if [[ -n "$branches" ]]; then
                    COMPREPLY=( $(compgen -W "$branches" -- "$cur") )
                fi
                return
            fi
            if (( COMP_CWORD == 2 )); then
                local branches
                branches=$(_gwt_branch_locals)
                if [[ -n "$branches" ]]; then
                    COMPREPLY=( $(compgen -W "$branches" -- "$cur") )
                fi
            elif (( COMP_CWORD == 3 )); then
                local bases
                bases=$(printf '%s\n' main master develop $(_gwt_branch_locals) | sort -u)
                COMPREPLY=( $(compgen -W "$bases" -- "$cur") )
            fi
            ;;
        new)
            local prev="${COMP_WORDS[COMP_CWORD-1]}"
            if [[ "$cur" == -* ]]; then
                COMPREPLY=( $(compgen -W "--agent --no-agent --detach -d --headless -H --no-user-pane --no-agent-pane" -- "$cur") )
                return
            fi
            if [[ "$prev" == "--agent" ]]; then
                return
            fi
            if (( COMP_CWORD == 2 || COMP_CWORD == 3 )); then
                local options
                options=$(_gwt_branch_locals)
                if [[ -n "$options" ]]; then
                    COMPREPLY=( $(compgen -W "$options" -- "$cur") )
                fi
            fi
            ;;
        info)
            local branches
            branches=$(_gwt_branch_worktrees)
            if [[ -n "$branches" ]]; then
                COMPREPLY=( $(compgen -W "$branches" -- "$cur") )
            fi
            ;;
        agent)
            if (( COMP_CWORD == 2 )); then
                COMPREPLY=( $(compgen -W "show set clear send output attach status clear-session" -- "$cur") )
            elif (( COMP_CWORD == 3 )); then
                local subcmd="${COMP_WORDS[2]}"
                case "$subcmd" in
                    send|output|attach|status|clear-session)
                        local branches
                        branches=$(_gwt_branch_worktrees)
                        if [[ -n "$branches" ]]; then
                            COMPREPLY=( $(compgen -W "$branches" -- "$cur") )
                        fi
                        ;;
                esac
            fi
            ;;
        completion)
            if (( COMP_CWORD == 2 )); then
                COMPREPLY=( $(compgen -W "bash zsh" -- "$cur") )
            fi
            ;;
    esac
}

complete -o default -F _gwt_completion gwt
EOS
}

print_completion_zsh() {
    cat <<'EOS'
#compdef gwt

_gwt_branch_worktrees() {
    git worktree list 2>/dev/null | sed -n 's/.*\[\(.*\)\].*/\1/p'
}

_gwt_branch_locals() {
    git branch --format='%(refname:short)' 2>/dev/null
}

_gwt() {
    local -a commands
    commands=(
        'new:Create a worktree and tmux session'
        'switch:Attach to an existing session'
        'list:List worktrees and sessions'
        'remove:Remove a worktree and session'
        'cleanup:Prune merged worktrees'
        'merge:Merge branch into base and clean up'
        'status:Show summary of worktrees'
        'push:Push the current branch'
        'from-pr:Create worktree from PR'
        'tmux-status:Internal status helper'
        'agent:Manage agent command and sessions'
        'info:Show comprehensive branch status'
        'sessions:List all tracked Claude sessions'
        'config-path:Show config file path'
        'completion:Print completion script'
        'version:Show CLI version'
        'help:Show usage'
    )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
        return
    fi

    local cmd=${words[2]}
    case $cmd in
        switch)
            local -a branches
            branches=(${(f)"$(_gwt_branch_worktrees)"})
            _describe 'branch' branches
            ;;
        remove)
            local current_arg=${words[CURRENT]}
            if [[ $current_arg == -* ]]; then
                local -a remove_opts
                remove_opts=(
                    '--keep-branch:Preserve the local git branch'
                )
                _describe 'option' remove_opts
                return
            fi
            local -a branches
            branches=(${(f)"$(_gwt_branch_worktrees)"})
            _describe 'branch' branches
            ;;
        cleanup)
            local -a bases
            bases=(${(f)"$(printf '%s\n' main master develop $(_gwt_branch_locals) | sort -u)"})
            _describe 'branch' bases
            ;;
        merge)
            local current_arg=${words[CURRENT]}
            local prev_arg=${words[CURRENT-1]}
            if [[ $current_arg == -* ]]; then
                local -a merge_opts
                merge_opts=(
                    '--keep:Skip branch and worktree cleanup'
                )
                _describe 'option' merge_opts
                return
            fi
            if [[ $prev_arg == --keep ]]; then
                local -a branches
                branches=(${(f)"$(_gwt_branch_locals)"})
                _describe 'branch' branches
                return
            fi
            if (( CURRENT == 3 )); then
                local -a branches
                branches=(${(f)"$(_gwt_branch_locals)"})
                _describe 'branch' branches
            elif (( CURRENT == 4 )); then
                local -a bases
                bases=(${(f)"$(printf '%s\n' main master develop $(_gwt_branch_locals) | sort -u)"})
                _describe 'branch' bases
            fi
            ;;
        new)
            local current_arg=${words[CURRENT]}
            local prev_arg=${words[CURRENT-1]}
            if [[ $current_arg == -* ]]; then
                local -a new_opts
                new_opts=(
                    '--agent:Set command to run in agent pane'
                    '--no-agent:Do not start an agent pane'
                    '--detach:Create session without attaching'
                    '-d:Create session without attaching'
                    '--headless:Run agent headlessly (no tmux)'
                    '-H:Run agent headlessly (no tmux)'
                    '--no-user-pane:Single pane with agent only'
                    '--no-agent-pane:Single pane with user only'
                )
                _describe 'option' new_opts
                return
            fi
            if [[ $prev_arg == --agent ]]; then
                return
            fi
            if (( CURRENT == 3 || CURRENT == 4 )); then
                local -a locals
                locals=(${(f)"$(_gwt_branch_locals)"})
                _describe 'branch' locals
            fi
            ;;
        info)
            local -a branches
            branches=(${(f)"$(_gwt_branch_worktrees)"})
            _describe 'branch' branches
            ;;
        agent)
            if (( CURRENT == 3 )); then
                local -a actions
                actions=(
                    'show:Print the configured agent command'
                    'set:Set the agent command'
                    'clear:Remove the agent command'
                    'send:Send message to agent'
                    'output:View agent output'
                    'attach:Attach to agent in tmux'
                    'status:Show agent status'
                    'clear-session:Clear session ID for fresh start'
                )
                _describe 'agent action' actions
            elif (( CURRENT == 4 )); then
                local subcmd=${words[3]}
                case $subcmd in
                    send|output|attach|status|clear-session)
                        local -a branches
                        branches=(${(f)"$(_gwt_branch_worktrees)"})
                        _describe 'branch' branches
                        ;;
                esac
            fi
            ;;
        completion)
            if (( CURRENT == 3 )); then
                local -a shells
                shells=(
                    'bash:Bash completion script'
                    'zsh:Zsh completion script'
                )
                _describe 'shell' shells
            fi
            ;;
        *)
            _default
            ;;
    esac
}

compdef _gwt gwt
EOS
}

cmd_completion() {
    local shell="${1:-}"
    case "$shell" in
        bash)
            print_completion_bash
            ;;
        zsh)
            print_completion_zsh
            ;;
        "")
            echo "Usage: gwt completion <bash|zsh>" >&2
            exit 1
            ;;
        *)
            echo "gwt: unsupported shell '$shell'" >&2
            exit 1
            ;;
    esac
}

cmd_agent_show() {
    echo "${GWT_AGENT_COMMAND:-}"
}

cmd_agent_set() {
    local command="$*"
    if [[ -z "$command" ]]; then
        echo "Usage: gwt agent set <command>" >&2
        exit 1
    fi
    set_config_value GWT_AGENT_COMMAND "$command"
    GWT_AGENT_COMMAND="$command"
    echo "Agent command set to: $command"
}

cmd_agent_clear() {
    set_config_value GWT_AGENT_COMMAND ""
    unset GWT_AGENT_COMMAND || true
    echo "Agent command cleared"
}

cmd_agent_send() {
    local branch="${1:-}"
    shift || true
    local message="$*"

    if [[ -z "$branch" ]]; then
        echo "Usage: gwt agent send <branch> <message>" >&2
        exit 1
    fi
    if [[ -z "$message" ]]; then
        echo "gwt agent send: message required" >&2
        exit 1
    fi

    require_git_repo
    local data
    data="$(get_session_data "$branch")"

    local mode session_id worktree_dir output_file
    mode=$(echo "$data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('mode',''))")
    session_id=$(echo "$data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('session_id',''))")
    worktree_dir=$(echo "$data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('worktree',''))")
    output_file=$(echo "$data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('output_file',''))")

    if [[ -z "$session_id" ]]; then
        echo "gwt: no session found for branch '$branch'" >&2
        echo "Use 'gwt new $branch --headless' to create a headless agent first" >&2
        exit 1
    fi

    if [[ "$mode" == "headless" ]]; then
        echo "→ sending message to headless agent..."
        # Use -p --resume for single-shot message
        (
            cd "$worktree_dir" || exit 1
            claude -p --resume "$session_id" \
                --output-format stream-json \
                --dangerously-skip-permissions \
                "$message" >> "$output_file" 2>&1
        )
        echo "✓ message sent (output appended to $output_file)"
    else
        # Tmux mode - send keys to agent pane
        local session
        session="$(session_name_for_branch "$branch")"
        if ! tmux has-session -t "$session" 2>/dev/null; then
            echo "gwt: tmux session not found for $branch" >&2
            exit 1
        fi
        tmux send-keys -t "$session:0.0" "$message" C-m
        echo "✓ message sent to tmux pane"
    fi
}

cmd_agent_output() {
    local branch="${1:-}"
    local raw=0
    local lines=50

    if [[ -z "$branch" ]]; then
        echo "Usage: gwt agent output <branch> [--raw] [-n <lines>]" >&2
        exit 1
    fi
    shift

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --raw) raw=1; shift ;;
            -n)
                if [[ $# -lt 2 ]]; then
                    echo "gwt agent output: -n requires a number" >&2
                    exit 1
                fi
                lines="$2"
                shift 2
                ;;
            *) shift ;;
        esac
    done

    require_git_repo
    local data
    data="$(get_session_data "$branch")"
    local mode output_file
    mode=$(echo "$data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('mode',''))")
    output_file=$(echo "$data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('output_file',''))")

    if [[ "$mode" == "headless" ]]; then
        if [[ ! -f "$output_file" ]]; then
            echo "gwt: no output file found for $branch" >&2
            echo "Send a message first: gwt agent send $branch 'message'" >&2
            exit 1
        fi
        if (( raw )); then
            tail -n "$lines" "$output_file"
        else
            # Parse stream-json and extract assistant content
            tail -n "$lines" "$output_file" | python3 -c "
import sys
import json

for line in sys.stdin:
    line = line.strip()
    if not line:
        continue
    try:
        obj = json.loads(line)
        if obj.get('type') == 'assistant' and 'content' in obj:
            for block in obj['content']:
                if block.get('type') == 'text':
                    print(block.get('text', ''))
    except json.JSONDecodeError:
        pass
"
        fi
    else
        # Tmux mode - capture pane
        local session
        session="$(session_name_for_branch "$branch")"
        if ! tmux has-session -t "$session" 2>/dev/null; then
            echo "gwt: tmux session not found for $branch" >&2
            exit 1
        fi
        tmux capture-pane -t "$session:0.0" -p -S -"$lines"
    fi
}

cmd_agent_attach() {
    local branch="${1:-}"
    if [[ -z "$branch" ]]; then
        echo "Usage: gwt agent attach <branch>" >&2
        exit 1
    fi

    require_git_repo
    require_command tmux

    local data
    data="$(get_session_data "$branch")"
    local session_id mode worktree_dir
    session_id=$(echo "$data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('session_id',''))")
    mode=$(echo "$data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('mode',''))")
    worktree_dir=$(echo "$data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('worktree',''))")

    if [[ -z "$worktree_dir" ]]; then
        worktree_dir="$(worktree_dir_for_branch "$branch")"
    fi

    if [[ -z "$worktree_dir" || ! -d "$worktree_dir" ]]; then
        echo "gwt: worktree not found for $branch" >&2
        exit 1
    fi

    local session
    session="$(session_name_for_branch "$branch")"

    # Kill existing tmux session if any
    tmux kill-session -t "$session" 2>/dev/null || true

    # Create new tmux session
    tmux new-session -d -s "$session" -c "$worktree_dir"

    # Style setup
    local color
    color="$(choose_random_color)"
    tmux set-option -t "$session" status-style "bg=$color,fg=black"
    tmux set-option -t "$session" status-interval 2
    tmux set-option -t "$session" status-left-length 80
    tmux set-option -t "$session" status-right-length 120
    tmux set-option -t "$session" status-left "#[fg=black,bold] #S "
    tmux set-option -t "$session" status-right "#[fg=black,bold]#(GWT_PANE_PATH='#{pane_current_path}' gwt tmux-status) "

    tmux rename-window -t "$session:0" "workspace"
    tmux split-window -t "$session:0" -h -c "$worktree_dir"

    # Resume Claude conversation in tmux
    if [[ -n "$session_id" ]]; then
        tmux send-keys -t "$session:0.0" "claude --resume $session_id --dangerously-skip-permissions" C-m
    else
        # No session ID - start fresh
        local agent_cmd="${GWT_AGENT_COMMAND:-claude --dangerously-skip-permissions}"
        local new_session_id
        new_session_id="$(generate_session_uuid "$branch")"
        if [[ "$agent_cmd" == claude* ]]; then
            agent_cmd="$agent_cmd --session-id $new_session_id"
        fi
        tmux send-keys -t "$session:0.0" "$agent_cmd" C-m
        set_session_data "$branch" "session_id" "$new_session_id"
    fi

    tmux send-keys -t "$session:0.1" "git status" C-m

    # Update mode to tmux
    set_session_data "$branch" "mode" "tmux"
    set_session_data "$branch" "worktree" "$worktree_dir"

    attach_tmux_session "$session"
}

cmd_agent_status() {
    local branch="${1:-}"
    require_git_repo

    if [[ -n "$branch" ]]; then
        # Show status for specific branch
        local data
        data="$(get_session_data "$branch")"
        if [[ -z "$data" || "$data" == "{}" ]]; then
            echo "No agent session for $branch"
            return
        fi
        echo "Branch: $branch"
        echo "$data" | python3 -c "
import json
import sys
d = json.load(sys.stdin)
for key, value in sorted(d.items()):
    print(f'  {key}: {value}')
"
    else
        # Show all sessions
        local sessions_file
        sessions_file="$(sessions_file_for_repo)"
        if [[ ! -f "$sessions_file" ]]; then
            echo "No tracked sessions"
            return
        fi
        python3 -c "
import json
with open('$sessions_file') as f:
    data = json.load(f)
if not data:
    print('No tracked sessions')
else:
    for branch, info in sorted(data.items()):
        mode = info.get('mode', '?')
        sid = info.get('session_id', '')[:12]
        print(f'{branch:25} {mode:10} {sid}...')
"
    fi
}

cmd_agent_clear_session() {
    local branch="${1:-}"
    if [[ -z "$branch" ]]; then
        echo "Usage: gwt agent clear-session <branch>" >&2
        exit 1
    fi
    require_git_repo
    remove_session_data "$branch"
    echo "✓ cleared session for $branch (next agent start will be fresh)"
}

cmd_info() {
    local branch="${1:-}"
    require_git_repo

    if [[ -z "$branch" ]]; then
        branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
    fi

    if [[ -z "$branch" ]]; then
        echo "Usage: gwt info <branch>" >&2
        exit 1
    fi

    local worktree_dir session session_data
    worktree_dir="$(worktree_dir_for_branch "$branch")"
    session="$(session_name_for_branch "$branch")"
    session_data="$(get_session_data "$branch")"

    # Output as parseable key=value format (also human readable)
    echo "branch=$branch"
    echo "repo=$(repo_name)"
    echo "tmux_session=$session"

    if [[ -n "$worktree_dir" && -d "$worktree_dir" ]]; then
        echo "worktree=$worktree_dir"
        echo "worktree_exists=true"

        # Git status
        local status_count
        status_count="$(git -C "$worktree_dir" status --porcelain 2>/dev/null | wc -l | tr -d ' ')"
        echo "uncommitted_changes=$status_count"

        # Upstream status
        local upstream ahead behind
        upstream=$(git -C "$worktree_dir" rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null || echo "")
        if [[ -n "$upstream" ]]; then
            ahead=$(git -C "$worktree_dir" rev-list --count '@{u}..HEAD' 2>/dev/null || echo 0)
            behind=$(git -C "$worktree_dir" rev-list --count 'HEAD..@{u}' 2>/dev/null || echo 0)
            echo "upstream=$upstream"
            echo "ahead=$ahead"
            echo "behind=$behind"
        else
            echo "upstream="
        fi
    else
        echo "worktree="
        echo "worktree_exists=false"
    fi

    # Tmux status
    if command -v tmux >/dev/null 2>&1 && tmux has-session -t "$session" 2>/dev/null; then
        echo "tmux_alive=true"
    else
        echo "tmux_alive=false"
    fi

    # Agent session info
    if [[ -n "$session_data" && "$session_data" != "{}" ]]; then
        local mode session_id output_file started_at
        mode=$(echo "$session_data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('mode',''))")
        session_id=$(echo "$session_data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('session_id',''))")
        output_file=$(echo "$session_data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('output_file',''))")
        started_at=$(echo "$session_data" | python3 -c "import json,sys; d=json.load(sys.stdin); print(d.get('started_at',''))")

        echo "agent_mode=$mode"
        echo "agent_session_id=$session_id"
        echo "agent_output_file=$output_file"
        echo "agent_started_at=$started_at"
    else
        echo "agent_mode="
        echo "agent_session_id="
    fi
}

cmd_sessions() {
    require_git_repo
    local sessions_file
    sessions_file="$(sessions_file_for_repo)"

    if [[ ! -f "$sessions_file" ]]; then
        echo "No tracked sessions"
        return
    fi

    printf 'Claude Sessions\n---------------\n'
    python3 -c "
import json
with open('$sessions_file') as f:
    data = json.load(f)
if not data:
    print('(none)')
else:
    for branch, info in sorted(data.items()):
        mode = info.get('mode', '?')
        sid = info.get('session_id', '')[:12]
        print(f'{branch:25} {mode:10} {sid}...')
"
}

cmd_config_path() {
    echo "$CONFIG_FILE"
}

cmd_version() {
    echo "gwt $GWT_VERSION"
}

main() {
    load_config
    ensure_config_dir

    # Parse global options before command dispatch
    local repo_path=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --repo-path)
                if [[ $# -lt 2 ]]; then
                    echo "gwt: --repo-path requires a path argument" >&2
                    exit 1
                fi
                repo_path="$2"
                shift 2
                ;;
            --repo-path=*)
                repo_path="${1#*=}"
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    # If repo path specified, cd to it
    if [[ -n "$repo_path" ]]; then
        if [[ ! -d "$repo_path" ]]; then
            echo "gwt: repo path does not exist: $repo_path" >&2
            exit 1
        fi
        cd "$repo_path" || exit 1
    fi

    local cmd="${1:-help}"
    shift || true
    case "$cmd" in
        new) cmd_new "$@" ;;
        switch) cmd_switch "$@" ;;
        list) cmd_list "$@" ;;
        remove) cmd_remove "$@" ;;
        cleanup) cmd_cleanup "$@" ;;
        merge) cmd_merge "$@" ;;
        status) cmd_status "$@" ;;
        push) cmd_push "$@" ;;
        from-pr) cmd_from_pr "$@" ;;
        tmux-status) cmd_tmux_status "$@" ;;
        agent)
            local sub="${1:-}"; shift || true
            case "$sub" in
                show) cmd_agent_show ;;
                set) cmd_agent_set "$@" ;;
                clear) cmd_agent_clear ;;
                send) cmd_agent_send "$@" ;;
                output) cmd_agent_output "$@" ;;
                attach) cmd_agent_attach "$@" ;;
                status) cmd_agent_status "$@" ;;
                clear-session) cmd_agent_clear_session "$@" ;;
                *) echo "Usage: gwt agent {show|set|clear|send|output|attach|status|clear-session}" >&2; exit 1 ;;
            esac
            ;;
        info) cmd_info "$@" ;;
        sessions) cmd_sessions ;;
        completion) cmd_completion "$@" ;;
        config-path) cmd_config_path ;;
        version|--version|-v|-V) cmd_version ;;
        help|-h|--help) print_usage ;;
        *) echo "Unknown command: $cmd" >&2; print_usage; exit 1 ;;
    esac
}

main "$@"
